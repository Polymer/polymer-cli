import * as dom5 from 'dom5';
import {predicates as p} from 'dom5';
import * as parse5 from 'parse5';
import * as stream from 'stream';
import * as url from 'url';

import File = require('vinyl');

const attrValueMatches = (attrName: string, regex: RegExp) => {
  return (node: parse5.ASTNode) => {
    const attrValue = dom5.getAttribute(node, attrName);
    return attrValue != null && regex.test(attrValue);
  };
};

const webcomponentsLoaderRegex = /\bwebcomponents\-(loader|lite)\.js\b/;
const webcomponentsLoaderMatcher = p.AND(
    p.hasTagName('script'), attrValueMatches('src', webcomponentsLoaderRegex));
const headMatcher = p.hasTagName('head');
const bodyMatcher = p.hasTagName('body');
const scriptMatcher = p.AND(
    p.hasTagName('script'),
    p.OR(
        p.NOT(p.hasAttr('type')),
        p.hasAttrValue('type', 'text/javascript'),
        p.hasAttrValue('type', 'application/javascript')));
const linkMatcher = p.AND(
    p.hasTagName('link'),
    p.OR(p.hasAttrValue('rel', 'import'), p.hasAttrValue('rel', 'stylesheet')));
const styleMatcher = p.AND(
    p.hasTagName('style'),
    p.OR(p.NOT(p.hasAttr('type')), p.hasAttrValue('type', 'text/css')));


/**
 * When compiling ES6 classes down to ES5 we need to include a special form of
 * the webcomponents loader to be compatible with native custom elements. This
 * includes moving the loader script element and all relevent siblings
 * following it into the body so that the Custom Elements ES5 adapter can be
 * properly injected.
 *
 * NOTE(fks) 03-28-2017: Comments are not currently moved to the body, which
 * means relevent comments may be left behind in the head. This is fine for now,
 * but may break if we ever decide to support important metadata in comments
 * (ex: support for defining lazy-imports via HTML comments).
 *
 * TODO(fks) 03-28-2017: Move into polymer-build and add tests.
 */
export class InjectES5Adapter extends stream.Transform {
  constructor() {
    super({objectMode: true});
  }

  async _transform(
      file: File,
      _encoding: string,
      callback: (error?: any, file?: File) => void) {
    let contents: string;
    if (file.contents === null || file.extname !== '.html') {
      callback(null, file);
      return;
    }
    if (file.isBuffer()) {
      contents = file.contents.toString('utf-8');
    } else {
      const stream = file.contents as NodeJS.ReadableStream;
      stream.setEncoding('utf-8');
      contents = '';
      stream.on('data', (chunk: string) => contents += chunk);
      await new Promise((resolve, reject) => {
        stream.on('end', resolve);
        stream.on('error', reject);
      });
    }
    if (!webcomponentsLoaderRegex.test(contents)) {
      callback(null, file);
      return;
    }
    const parsed = parse5.parse(contents);
    const script = dom5.nodeWalk(parsed, webcomponentsLoaderMatcher);
    if (!script) {
      callback(null, file);
      return;
    }

    // Collect important dom references & create fragments for injection
    const correctedFile = file.clone();
    const headElement = dom5.query(parsed, headMatcher)!;
    const bodyElement = dom5.query(parsed, bodyMatcher)!;
    const loaderScriptUrl = dom5.getAttribute(script, 'src')!;
    const adapterScriptUrl =
        url.resolve(loaderScriptUrl, 'custom-elements-es5-adapter.js');
    const es5AdapterScript = parse5.parseFragment(`
    <!-- This block adds the "custom-elements-es5-adapter.js" shim to your application.
         It includes special logic that removes the shim before it can be parsed or run
         on browsers without native support for ES2015+ & custom elements. -->
    <div id="autogenerated-ce-es5-shim">
      <script type="text/javascript">
        if (!window.customElements) {
          var ceShimContainer = document.querySelector('#autogenerated-ce-es5-shim');
          ceShimContainer.parentElement.removeChild(ceShimContainer);
        }
      </script>
      <script type="text/javascript" src="${adapterScriptUrl}"></script>
    </div>
  `);
    if (!bodyElement.childNodes) {
      bodyElement.childNodes = [];
    }

    // If script is already in the body, just insert the shim right before it.
    if (dom5.nodeWalkAncestors(script, bodyMatcher)) {
      dom5.insertBefore(bodyElement, script, es5AdapterScript);
      correctedFile.contents = new Buffer(parse5.serialize(parsed), 'utf-8');
      callback(null, correctedFile);
      return;
    }

    // Otherwise we need to move the webcomponents-loader/webcomponents-lite
    // loader down to the body so that the es5 adaperter script shim will work.
    // Any following scripts, styles, and imports need to be moved down to the
    // body as well to preserve ordering.
    const orderSensitiveSiblings = dom5.queryAll(
        script.parentNode!, p.OR(scriptMatcher, styleMatcher, linkMatcher));
    const scriptIndex = orderSensitiveSiblings.indexOf(script);
    const afterScriptSiblings = orderSensitiveSiblings.slice(scriptIndex);
    const loaderMovedComment = dom5.constructors.comment(
        ' AUTO-GENERATED BY polymer-cli: "webcomponents-loader.js" and ' +
        'related resources have been moved to <body> so that ' +
        '"custom-elements-es5-adapter.js" polyfill could be properly ' +
        'injected into this file. ');

    // Insert a "loader moved" comment fragment into the head.
    dom5.insertBefore(headElement, script, loaderMovedComment);
    // Move elements to the top of the body in reverse order, so that the
    // first moved element is prepended last, preserving the original order.
    afterScriptSiblings.reverse();
    for (const releventScript of afterScriptSiblings) {
      dom5.insertBefore(
          bodyElement, bodyElement.childNodes[0] || null, releventScript);
    }
    // Finally, inject the es5-adapter shim at the top of the body.
    dom5.insertBefore(
        bodyElement, bodyElement.childNodes[0] || null, es5AdapterScript);

    correctedFile.contents = new Buffer(parse5.serialize(parsed), 'utf-8');
    callback(null, correctedFile);
  }
}